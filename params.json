{"name":"miniconf","tagline":"A minimalist C++ configuration manager","body":"# miniconf\r\n\r\nminiconf is a minimalist C++ configuration manager.\r\n\r\nminiconf only contains one C++ header file. It is not meant to be fast, but it is designed to make C++ programs simpler and more flexible for prototyping, research, and development in general.\r\n\r\n#### main features\r\n\r\n* *It is a smart argument parser*: format checking, input validation, default values, etc.\r\n* *It is also a config file reader*: It supports reading from JSON and CSV.\r\n* It can serialize settings to JSON or CSV files and reuses them later.\r\n* It generates help and usage message automatically\r\n\r\n## One Minute Quick Start\r\n\r\n#### An Example\r\n\r\nminiconf uses a very simple API for configuring for an application, a working example is shown below:\r\n\r\n```c++\r\nint main(int argc, char** argv)\r\n{\r\n    /* create a Config object */\r\n    miniconf::Config conf;\r\n\r\n    /* Setup config options */\r\n    /* Option properties, e.g. shortened flag, default values... */\r\n    conf.option(\"numOpt\").shortflag(\"n\").defaultValue(3.14).required(false).description(\"A number value\");\r\n    conf.option(\"boolOpt\").shortflag(\"b\").defaultValue(false).required(true).description(\"A boolean value\");\r\n    conf.option(\"strOpt\").shortflag(\"s\").defaultValue(\"string\").required(true).description(\"A string value\");\r\n\r\n    /* parse */\r\n    bool success = conf.parse(argc, argv);\r\n    if (success){\r\n        /* processing the configuration here ... */\r\n    } \r\n    else \r\n    {\r\n        /* report error here ... */\r\n    }\r\n    return 0;\r\n}\r\n```\r\n\r\n------------------------------------------------------------------------\r\n\r\n#### Configuring an application via command line / input file\r\n\r\nUser can modify the configuration settings by command line, for example:\r\n\r\n```bash\r\n$ ./program --numOpt 6.28 --boolOpt true -s \"another string\"\r\n```\r\n\r\nAlternatively, a config file can also be used, both JSON and CSV formats are supported, the file format is determined by the input file's extension, for example:\r\n\r\n```bash\r\n$ ./program --config settings.json -s \"overwritten\"\r\n```\r\nor \r\n\r\n```bash\r\n$ ./program --config settings.csv -s \"overwritten\"\r\n```\r\n\r\nWhere the content of config file \"settings.json\" is:\r\n\r\n```json\r\n{\r\n   \"numOpt\": 6.28,\r\n   \"boolOpt\": true, \r\n   \"stringOpt\": \"this will be overwritten\"\r\n}\r\n```\r\n\r\nand in settings.csv, the content will be:\r\n\r\n```\r\nnumOpt,6.28\r\nboolOpt,true\r\nstringOpt,this will be overwritten\r\n```\r\n\r\nNote that command-line arguments has a higher priority so the attribute \"stringOpt\" in the json file will be overwritten by \"-s/--stringOpt\" in the command-line. \r\n\r\nThe configurations in the above two examples should be the same when parsed by miniconf:\r\n \r\n* _numOpt_ = 6.28\r\n* _boolOpt_ = true\r\n* _stringOpt_ = \"overwritten\"\r\n\r\nA configuration file can also be loaded programmatically using the C++ Config::config() function, for example:\r\n\r\n```C++\r\n// create a Config object\r\nminiconf::Config conf;\r\n\r\n/* ... some parsing here if necessary ... */\r\n\r\n// load (and possibly overwrite) the current config with the input json file\r\nconf.config(\"settings.json\");\r\n\r\n```\r\n\r\nThe miniconf::Config::parse() function returns a boolean which indicates whether the parsing process is performed successfully.\r\n\r\n------------------------------------------------------------------------\r\n\r\n#### Accessing configuration settings\r\n\r\nConfiguration values can be read by specifying their type _implicitly_, if output data type can be determined, for example:\r\n\r\n```c++\r\ndouble n = conf[\"numOpt\"];\r\nbool b = conf[\"boolOpt\"];\r\nstd::string s = conf[\"strOpt\"];\r\n```\r\n\r\nor, user may also define the configuration value _explicitly_:\r\n\r\n```c++\r\ndouble n = conf[\"numOpt\"].getNumber();\r\nbool b = conf[\"boolOpt\"].getBoolean();\r\nstd::string s = conf[\"strOpt\"].getString();\r\n```\r\n------------------------------------------------------------------------\r\n\r\n## Advanced Features\r\n\r\n#### Nested configuration\r\n\r\nNested configuration is support in miniconf with JSON, for example:\r\n\r\n```c++\r\n   // Setup config options \r\n   // Option properties, e.g. short flag\r\n   conf.option(\"a.b.c\").shortflag(\"c\").defaultValue(\"c_val\").required(false).description(\"A nested value\");\r\n   conf.option(\"a.b.d\").shortflag(\"d\").defaultValue(\"d_val\").required(false).description(\"A nested value\");\r\n   conf.option(\"a.e\").shortflag(\"e\").defaultValue(\"e_val\").required(false).description(\"A nested value\");\r\n```\r\n\r\nWith the command line arguments which overrides the original default values:\r\n\r\n```bash\r\n./program --a.b.c overwritten_c_val\r\n```\r\n\r\nthe parsed configuration is:\r\n\r\n* _a.b.c_ = \"overwritten_c_val\"\r\n* _a.b.d_ = \"d\"\r\n* _a.e_ = \"e\"\r\n\r\nand the exported JSON file it will become:\r\n\r\n```json\r\n{\r\n    \"a\": {\r\n        \"b\" : {\r\n            \"c\" : \"overwritten_c_val\",\r\n            \"d\" : \"d\" \r\n        },\r\n        \"e\" : \"e\"\r\n    }\r\n}\r\n```\r\n\r\n------------------------------------------------------------------------\r\n\r\n#### Modifying Configuration Settings\r\n\r\nConfiguration values can also be modified during runtime:\r\n\r\n```c++\r\nconf[\"numOpt\"] = 9.42;\r\nconf[\"strOpt\"] = \"fourth string\";\r\nconf[\"boolOpt\"] = false;\r\n```\r\nOr one can also do explicitly\r\n\r\n```c++\r\nconf[\"numOpt\"] = mimiconf::Value(12.56);\r\n```\r\n\r\n------------------------------------------------------------------------\r\n\r\n#### Print current configuration summary\r\n\r\nUser may print the current configuration settings using the Config::print() function:\r\n\r\n```c++\r\nconf.print(); // print current settings\r\n```\r\n\r\nThe output will be (The default output file is stdout):\r\n\r\n```bash\r\n[[[  CONFIGURATION  ]]]\r\n\r\n|-------------------------|------------|--------------------------------------------------|\r\n|           NAME          |    TYPE    |                     VALUE                        |\r\n|-------------------------|------------|--------------------------------------------------|\r\n| boolOpt                 | BOOLEAN    | false                                            |\r\n| intOpt                  | INT        | 122                                              |\r\n| numOpt                  | NUMBER     | 3.140000                                         |\r\n| strOpt                  | STRING     | \"string\"                                         |\r\n|-------------------------|------------|--------------------------------------------------|\r\n\r\n```\r\n\r\n------------------------------------------------------------------------\r\n\r\n#### Automated Help / Usage Message Generation\r\n\r\nThe function Config::help() generates and displays a help message, which looks like the message below:\r\n\r\n```\r\n[[[  USAGE  ]]]\r\n\r\n    example -b <BOOLEAN> [-cfg <STRING>] [-h <BOOLEAN>] [-n <NUMBER>] -s <STRING> \r\n\r\n\r\n[[[  HELP  ]]]\r\n\r\n    -b, --boolOpt <REQUIRED>\r\n        A boolean value  ( DEFAULT = false ) \r\n\r\n    -cfg, --config \r\n        Load the config file. Config format is determined by the file's extenion. If no file extension is found, default JSON loader is used  ( DEFAULT = \"\" ) \r\n\r\n    -h, --help \r\n        Display the help message  ( DEFAULT = false ) \r\n\r\n    -n, --numOpt \r\n        A number value  ( DEFAULT = 3.140000 ) \r\n\r\n    -s, --strOpt <REQUIRED>\r\n        A string value  ( DEFAULT = \"string\" ) \r\n```\r\n\r\n\r\nThe upper \"usage\" section can be displayed indepdently using the Config::usage() function. \r\n\r\nThe \"auto-help\" feature is enabled in miniconf by default, which means that an extra hidden option \"--help/-h\" is added to the configuration by default. The help message will be displayed to stdout when \"--help/-h\" is true. One can change the auto-help features by *Config::enableHelp()*.\r\n\r\n------------------------------------------------------------------------\r\n\r\n#### Serialization / programmatic config file loading\r\n\r\nminiconf supports serialization to JSON / CSV formats:\r\n```c++\r\n// serialize current settings\r\nconf.serialize(\"output_settings.json\", Config::ExportFormat::JSON);\r\n\r\n```\r\nTwo file formats, *Config::ExportFormat::JSON* and *Config::ExportFormat::CSV* are supported. The exported config files can be loaded back by using the \"--config\" argument, or the \"Config::config()\" function.\r\n\r\n#### Vanilla version: JSON-less version\r\n\r\nmimiconf requires a json parser to support JSON export and import, currently we are using picojson [GITHUB](https://github.com/kazuho/picojson) as the backend JSON parser. \r\n\r\nIf one wants to remove the JSON dependency (to reduce code size, to remove the BSD license, etc.), one might need to uncomment the line \r\n```c++\r\n#define MINICONF_JSON_SUPPORT\r\n```\r\nin miniconf.h\r\n\r\n#### Extra configuration values\r\n\r\nUnrecognized option flags are treated as \"extra configuration values\", they will not be neglected and are processed according to how the setting is given to the miniconfig parser:\r\n\r\nIf it is given as a command line argument, or CSV file, it will be parsed as a string value, for example:\r\n```bash\r\n./program --extra 123\r\n```\r\nThe option value of flag \"extra\" will be a string of \"123\".\r\n\r\nAlternatively if it is given as a JSON file, it will try to parse the default data type interpreted by the JSON file:\r\n```json\r\n{\r\n    \"extra1\" : 123,\r\n    \"extra2\" : \"extra string\"\r\n}\r\n```\r\nThe option value of flag \"extra1\" will be a number of value 123.0, and the option value of flag \"extra2\" will be a string of \"extra string\".\r\n\r\n*Note:*\r\n\r\n* Shortened flags are not supported and will be ignored.\r\n* Values without any flag are not supported and will be ignored.\r\n\r\n#### validation and logging\r\n\r\nBy default, the configuration settings and the option values given by the user will be automatically checked and validated in the  miniconf::Config::parse() function. Before parsing the argument, user can set the logging level of config checker using the miniconf::Config::log() function. \r\n\r\nFor example, if the user wants to log all the messages:\r\n```c++\r\nconf.log(miniconf::Config::LogLevel::INFO);\r\n```\r\nOn the other hand, if the user wants to log fatel errors only:\r\n```c++\r\nconf.log(miniconf::Config::LogLevel::ERROR);\r\n```\r\nThe with the return value of parse() function, user might want to write a simple error checker like this:\r\n```c++\r\n/* set log level to \"warning\" which logs non-fatal warning as well */\r\nconf.log(miniconf::Config::LogLevel::WARNING); \r\n/* parse the arguments, if error, print log and quit */\r\nif (conf.parse(argc, argv)){\r\n    // perform normal tasks...\r\n} else {\r\n    /* display erorr log */\r\n    conf.log();\r\n    exit(1);\r\n}\r\n```\r\n\r\n------------------------------------------------------------------------\r\n## About miniconf\r\nminiconf is licensed under the unlicense license. :)\r\n\r\nPlease also visit the project's website: http://thyu.github.io/miniconf/\r\n\r\nAuthor: Tsz-Ho Yu (thyu413@gmail.com)\r\n\r\nWebsite: http://www.tszho.net/\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}